rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: check if the requesting user is in the allowed list
    function isAllowedUser() {
      return request.auth != null
        && request.auth.uid in get(/databases/$(database)/documents/config/allowedUsers).data.uids;
    }

    // Projects: read for allowed users; scoped update for burstMode toggle
    match /projects/{projectId} {
      allow read: if isAllowedUser();
      allow update: if isAllowedUser()
        && request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(['burstMode', 'updatedAt']);
      allow create, delete: if false;  // Only Admin SDK (CLI) can create/delete

      // Context subcollection: read for allowed users, write via Admin SDK only
      match /context/{sectionName} {
        allow read: if isAllowedUser();
        allow write: if false;
      }
    }

    // Stories: read for allowed users; scoped update for notes only
    match /stories/{storyId} {
      allow read: if isAllowedUser();
      allow update: if isAllowedUser()
        && request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(['notes', 'noteReactions', 'updatedAt', 'status', 'previousStatus', 'blockedReason',
                        'title', 'description', 'userStory', 'epicName', 'priority', 'complexity', 'assignedAgent', 'tags', 'tokenUsage', 'reservedFiles']);
      allow create: if isAllowedUser()
        && request.resource.data.keys().hasAll([
             'id', 'shortId', 'projectId', 'title', 'description', 'userStory',
             'epicName', 'acceptanceCriteria', 'status', 'previousStatus',
             'blockedReason', 'priority', 'complexity', 'assignedAgent',
             'notes', 'noteReactions', 'createdAt', 'updatedAt'
           ])
        && request.resource.data.status in ['backlog', 'ideas']
        && request.resource.data.previousStatus == null
        && request.resource.data.title is string && request.resource.data.title.size() > 0
        && request.resource.data.projectId is string && request.resource.data.projectId.size() > 0
        && request.resource.data.priority in ['P0', 'P1', 'P2', 'P3']
        && request.resource.data.complexity in ['S', 'M', 'L', 'XL'];
      allow delete: if false;  // Only Admin SDK (CLI) can delete

      // Activity subcollection: read + create for allowed users
      match /activity/{activityId} {
        allow read: if isAllowedUser();
        allow create: if isAllowedUser();
      }
    }

    // Agents: read-only for authenticated allowed user
    match /agents/{agentId} {
      allow read: if isAllowedUser();
      allow write: if false;
    }

    // Counters: allowed users can read/write (needed for atomic shortId generation)
    match /counters/{counterId} {
      allow read, write: if isAllowedUser();
    }

    // Config: read for allowed users; scheduler doc is editable for maxConcurrentSessions
    match /config/{configId} {
      allow read: if isAllowedUser();
      allow update: if isAllowedUser()
        && configId == 'scheduler'
        && request.resource.data.diff(resource.data).affectedKeys()
             .hasOnly(['maxConcurrentSessions']);
      allow create, delete: if false;
    }

    // Meetings: read for allowed users; write via CLI/Admin SDK only
    match /meetings/{meetingId} {
      allow read: if isAllowedUser();
      allow write: if false;  // Only Admin SDK (CLI) can create/update
    }

    // Webhook events: read-only for authenticated allowed user
    match /webhookEvents/{eventId} {
      allow read: if isAllowedUser();
      allow write: if false;  // Only Admin SDK (Cloud Functions) can write
    }

    // Default deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
